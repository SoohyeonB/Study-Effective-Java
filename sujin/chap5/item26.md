## 아이템 26. 로 타입은 사용하지 말라

### 제너릭 용어 정리

#### 제네릭 클래스, 제네릭 인터페이스

- 클래스와 인터페이스 선언에 타입 매개변수가 쓰인 경우
- ex) `List<E>`
- 통틀어서 제너릭 타입이라고 한다.

#### 매개변수화 타입
  
- ex) `List<String>`
- 여기에서 String이 타입 매개변수 E에 해당하는 실제 타입 매개변수이다.

#### 로 타입
- 제너릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때
- ex) `List<E>`의 로 타입은 `List`이다.

### 로 타입을 쓰면?
```java
// Stamp 인스턴스만 취급한다.
private final Collection stamps = ...;
```
- 만약 도장을 담는 컬렉션에 동전을 넣어도 컴파일되고 실행된다.
- 한참 뒤 런타임에야 오류가 발생할 수 있다.
   - add한 Coin 객체를 꺼내서 Stamp 변수에 할당하면 ClassCastException이 발생한다.

**로 타입은 제너릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.**

### 제너릭을 사용하자.
제너릭을 활용하면 위 예제의 'Stamp 인스턴스만 취급한다.'는 정보가 주석이 아닌 타입 선언 자체에 녹아든다.
```java
private final Collection<Stamp> stamps = ...;
```
- 컴파일러는 stamps에 Stamp의 인스턴스만 넣어야함을 인지하게 된다.
- 따라서 타입 안정성을 확보할 수 있다.

### `List<Object>`는 사용해도 괜찮다.
`List<Object>`는 모든 타입을 허용한다는 매개변수화 타입이다.
- 매개 변수로 `List`를 받는 메서드에 `List<String>`을 넘길 수 있다.
- 하지만 `List<Object>`를 받는 메서드에는 넘길 수 없다.
   - 제너릭의 하위 타입 규칙 때문이다.
 
**`List<String>`은 로 타입인 List의 하위 타입이지만, `List<Object>`의 하위 타입은 아니다.**
  
### 원소의 타입을 신경쓰고싶지 않다면?
**비한정적 와일드카드 타입을 사용하자!**
- 제너릭 타입인 `Set<E>`의 비한정적 와일드카드 타입은 `Set<?>`이다.
- 로 타입 컬렉션에는 아무 원소나 넣을 수 있어서 타입 불변식을 훼손하기 쉽다.
- 하지만 Collection<?>에는 null 외에는 어떤 원소도 넣을 수 없다.
