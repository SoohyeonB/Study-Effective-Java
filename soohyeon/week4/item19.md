# 아이템 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

## 상속을 하기 위한 방법

### 방법1 - 문서로 남기기

> API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수 있는데, 그 호출되는 메서드가 **재정의 가능 메서드**이면 그 사실을 호출하는 메서드 API에 명시해야 한다.
> 

**즉, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨해야 한다는 뜻이다.** 

그럼 문서는 어디에 작성해야 하는걸까?

API 문서 메서드 설명 끝에 그 메서드의 내부 동작 방식을 설명하는 “Implementation Requirements”라는 절이 있다. 이 부분은 @implSpec 태그를 주석에 붙여주면 자바독 도구가 생성해준다. 

<aside>
💡 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

</aside>

*@implSpec은 선택사항으로 남아있지만 되도록이면 활성화해서 사용해주는 것이 바람직하다. 

### 방법 2 - protected 메서드 형태로 공개하기

> 하위 클래스를 잘 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 **훅(hook)을 잘 선별하여** **protected 메서드 혹은 필드 형태로 공개**한다.
> 

**예시 - removeRange**

```java
protected void removeRange(int formIndex, int toIndex)
```

> 해당 리스트 혹은 이 리스트의 부분 리스트에 정의된 clear 연산이 이 메서드를 호출한다. 리스트 구현의 내부 구조를 활용하도록 이 메서드를 **재정의**하려면 이 리스트와 부분 리스트의 clear 연산 성능을 크게 **개선**할 수 있다.
> 

List 구현체의 최종 사용자는 removeRange 메서드에는 관심이 없다. 

그럼 왜 이 메서드를 제공했을까?

▶️ 단지 하위 클래스에서 부분리스트의 clear 메서드를 **고성능**으로 만들기 쉽게 하기 위해서이다. 

**Q. 어떤 메서드를 protected로 노출하는지 어떻게 결정할까?**

1. 잘 예측하고
2. **실제 하위클래스를 만들어 시험해본다.** 

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 ‘유일’하다. 

확인해보자

- 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러남
- 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 함
- 실제 검증에는 하위 클래스 3개가 적당
- 하나 이상의 클래스는 제3자가 작성하기

## 상속을 허용하는 클래스가 지켜야 할 제약

### 01 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.

> 상속용 클래스의 생성자는 직접적이로든 간접적이로든 재정의 가능 메서드를 호출해서는 안된다.
> 

왜?

상위 클래스의 생성자가 하위 클래스의 생성자보다 항상 먼저 호출되기 때문이다. 이 때문에 재정의한 메서드가 하위 클래스의 생성자에서 수정한 값에 의존한다면 프로그램이 오작동할 것이다. 

예시를 같이 보자

상의 클래스의 생성자가 재정의 가능 메서드를 호출한다.

```java
public calss Super{
	//잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
	public super() {
		overrideMe(); //재정의 가능 메서드
	}
	public void overrideMe() { //NULL
	}
}
```

하위 클래스

```java
public final class Sub extends Super {
	//초기화되지 않은 final 필드. 생성자에서 초기화한다.
	private final Instant instant;
	Sub() {
		instant = Instant.now();
	}
	
	//재정의 가능 메서드. 상위 클래스의 생성자가 호출한다. 
	@Oberride public void overrideMe() {
		System.out.println(instant);
	}
	
	public static void main(String[] args) {
		Sub sub = new Sub();
		sub.overrideMe();
	}
}
```

상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기 전에 overrideMe를 호출하기 때문에 NullPointerException을 던진다. 하지만 이곳에서는 println이 null을 입력으로 받아들이기 때문에 null이 출력된다. 

### 02 cloneable과 Serializable 인터페이스를 하위 클래스에서 구현하려면 특별한 방법을 따르라.

> 클래스를 확장하기 위해서는 프로그래머가 엄청난 부담을 극복해야 하기 때문에 비추한다. 
**따라서 clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.**
> 

특별한 방법은 아이템 13과 아이템 86에서 이야기 한다. 

1. **Clone**

하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 먼저 호출한다. 또한 readObject에서도 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다. 이는 프로그램 오작동으로 이어진다. 

특히 clone에서는 아이템 13에서 언급했듯이 잘못 사용하면 원본객체에도 영향을 줄 수 있기 때문에 clone 재정의는 지양한다. 

1. **Serializable**

구현한 상속용 클래스가 readResolve난 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protectec로 선언해야 한다. 

왜?

private으로 선언하게 되면 하위 클래스에서 무시되기 때문에 상속을 허용하기 위해서는 내부 구현을 클래스 API로 공개하는 것이 좋다. 

---

## 구체 클래스의 상속

위에서 언급한 클래스가 아닌 일반적인 구체 클래스의 상속을 어떻게 하는 것이 좋을까?

구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화 되지도 않았다.

BUT

이대로 둔다면 클래스에 변화가 생길 때마다 하위 클래스를 **오작동**하게 만들 수 있다. 

그렇다면 어떻게 해결하나?

### 해결방법 - 상속을 금지하라

> 가장 좋은 해결 방법은 상속용으로 설계하지 않은 클래스는 **상속을 금지**하는 것이다.
> 

방법 1 - 클래스를 final로 선언하라

방법 2 - 모든 생성자를 private이나 package-private으로 선언하고 pubilc 정적 팩터리를 만들어준다.  

아이템 1에서 다룬 장점 참고

[정적 팩토리 메서드(Static Factory Method)는 왜 사용할까?](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)

### 그래도 상속을 하고 싶다면?

상속은 되도록 하지 않는 것이 좋기 때문에 **상속을 금지**하는 것이 좋다. 하지만 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기 불편해지므로, 이를 해결하기 위해서는 두 가지 방법을 제시한다. 

1. **문서로 남기는 방법**
재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남긴다. 
이 경우 메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않게 된다. 
2. **재정의 가능 메서드를 사용하는 코드를 제거하는 방법**
모든 재정의 가능 메서드는 자신의 본문 코드를 private 도우미 메서드로 옮기고 이 도우미 메서드를 호출하도록 수정한다. 그 후 재정의 가능 메서드를 호출하는 다른 코드들도 모두 도우미 메서드를 직접 호출하도록 수정한다. 

## 결론

<aside>
💡 상속용 클래스를 설계하기 위해서는 모두 **문서**로 만들어야 한다. 
클래스를 확장해야 할 명확한 이유가 없으면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들어 상속을 금지하는 것이 낫다.

</aside>
