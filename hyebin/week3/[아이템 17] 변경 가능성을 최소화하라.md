# [아이템 17] 변경 가능성을 최소화하라

**웬만하면 불변클래스 설계하기**

만약 불변 클래스 선언시 성능상 문제가 심각하다면 **가변 동반 클래스 활용하기**

불변 클래스로 도저히 만들 수 없다면 **변경할 수 있는 부분이라도 최소화하기**

확실한 이유가 없다면 **생성자와 정적 팩터리 외에는 초기화 메서드를 public으로 두지 않기**

## 불변클래스

불변클래스란 **인스턴스 내부 값을 수정할 수 없는 클래스**

인스턴스 내부 정보는 해당 객체가 파괴되는 순간까지 변동 없음

ex_ String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal

## 불변 클래스 생성 규칙

### 1. 객체 상태 변경 메서드 (aka.setter)를 제공하지 않기

### 2. 클래스 확장할 수 없도록 하기 (상속 막기)

클래스의 생성자를 `final`로 설정한다.

OR

👍 추천) 모든 생성자를 `private` 혹은 `package-private`으로 설정하고 **public 정적 팩터리 제공** 

다수의 구현 클래스를 활용한 유연성 제공, 다음 릴리즈에서 객체 캐싱 기능을 추가할 수 있음

### 3. 모든 필드를 final로 선언하기

설계자의 의도를 보다 명확하게 표현하는 방법

### 4. 모든 필드를 private으로 선언하기

필드가 참조하는 가변객체를 클라이언트는 접근할 수 없어진다.

기본 타입 필드나 불변 객체는 `public final`로 해도 기술적으로는 가능하지만 항상 릴리즈를 고려했을 때 public 타입의 필드는 내부 수정이 어려워 웬만하면 지양한다.

### 5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 하기

**가변 객체를 참조하는 필드를 클라이언트가 절대 접근하게 하면 안됨**

해당 필드 제공은 생성자, 접근자(getter), readObject 메서드에서 방어적 복사를 통해 하기

## 함수형 프로그래밍

함수형 프로그래밍이란 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 값을 변화시키지 않고 새로운 인스턴스를 통해서 결과를 반환하는 프로그래밍을 말한다. 

```java
public final class Complex{
	private final double re;
	private final double im;
	
	..
	public Complex plus(Complex c){
	return new Complex(re+c.re, im+c.im);
	}
```

위와 같이 인스턴스 자신은 수정하지 않고 새로운 인스턴스를 만들어서 반환한다.

이 때 메서드 이름으로 (add 같은) 동사 대신 (plus) 전치사를 사용하는 것이 명명 규칙이다.

## 불변 객체의 장점

불변 객체는 단순하다.

반면 가변 객체는 임의의 복잡한 상태에 놓일 수 있어서 상태 전이를 정밀하게 문서화해야 한다.

**불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.**

따라서 안심하고 공유할 수 있다.

또한 불변 객체는 변하지 않으니 방어적 복사도 할 필요가 없어진다. 

## 불변 객체 재활용

불변 클래스는 한 번 만든 인스턴스를 최대한 재활용하는 것이 좋다.

### 1. 자주 쓰이는 인스턴스들은 상수(`public static final` )화 하기

### 2. 자주 쓰이는 인스턴스를 캐싱하는 정적 팩터리 제공하기

여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.

**새로운 클래스를 설계할 때 public 생성자 대신 정적 팩터리를 만들어 두면, 클라이언트를 수정하지 않고도 필요에 따라 캐시 기능을 나중에 덧붙일 수도 있다.**

### 3. clone 메서드나 복사 생성자 제공하지 않기

어차피 불변 객체는 안변해서 복사를 할 필요가 없다. 이미 만들어진 인스턴스 쓰게 하기

## 불변 객체 활용

### 1. 불변 객체끼리 내부 데이터를 공유하기

```java
public class BigInteger{
	private final int sign;
	private fianl int[] magnitude; //가변 객체
	
public BigInteger negate(){
	return new BigInteger(sign*-1,magnitude);
	}
```

magnitude는 가변이지만 복사하지 않고 내부적으로 원본 인스턴스와 필드를 공유한다. 

어차피 `private fianl`이기 때문에 클라이언트는 두 불변 객체의 배열 필드에 접근할 수 없다.

### 2. 불변식을 유지하기 쉽다

Map의 키나 집합(Set)의 원소로 쓰기 좋다

### 3. 실패 원자성 ( 예외가 발생한 후에도 상태가 변하지 않음)

## 불변 객체의 단점

### 1. 값이 다르면 반드시 독립된 객체 ⇒ 값의 가짓수가 많으면 비용도 커짐

딱 하나의 값만 바뀌어도 모든 값을 새롭게 다시 가진 객체를 생성해야 한다

원하는 객체를 완성하기까지의 단계가 많고 그 중간 단계에서 만들어진 객체들이 버려진다면 성능 문제가 붉어진다.

**solution?**

1. 가변 동반 클래스 
    
    클라이언트가 원하는 연산들을 미리 예측해서 `package-private`으로 같이 두는 것
    
    ex_ String 의 가변 동반 클래스는 StringBuilder
