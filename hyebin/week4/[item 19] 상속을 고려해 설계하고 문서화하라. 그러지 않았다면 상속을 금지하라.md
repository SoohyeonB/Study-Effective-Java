# [item 19] 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

## 들어가기에 앞서

이 아이템은 **외부의 다른 개발자가 나의 클래스를 상속 받을 경우를 고려한 상황**이다.  
따라서 만약 단순히 나의 클래스의 객체만 만들어서 외부의 개발자가 사용한다면 굳이 문서화할 필요가 없다.

# 상속을 고려한 클래스의 원칙

## 1. 상속을 고려한 클래스의 재정의

### 재정의를 허용하는 메서드

재정의 가능이란 `public` `protected` 메서드 중 **final이 아닌** 모든 메서드를 뜻한다.

상속용 클래스는 이와 같이 재정의할 수 있도록 정의된 메서드들이 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

### Hook 선별하여 protected 메서드 형태로 공개하기

효율적인 하위 클래스 동작 구현을 위해 클래스의 내부 동작에 끼어들 수 있는 hook 메서드의 재정의 가능성을 열어둔다.

<aside>
🌼 예시 : java.util.AbstractList의 removeRange 메서드

removeRange 메서드는 사용자가 지정한 범위 내에 있는 인스턴스를 제거하는 역할을 하는 메서드이다.
이 메서드는 프로그래머가 `clear` 메서드를 실행하면 내부적으로 동작하는 Hook 메서드이다. 이 때 이 메서드의 삭제 연산 방식에 따라 성능의 차이가 크게 날 수 있다.
이런 경우 해당 메서드를 사용할 프로그래머가 `removeRange` 메서드를 재정의하여 성능을 높일 수 있도록 이 메서드를 protected로 열어둔다.

</aside>

## 2. 하위클래스로 테스트하라!

상속용 클래스를 시험하는 방법은 **직접 하위 클래스를 만드는 것**

꼭 필요한 `protected` 멤버를 놓쳤으면 하위 클래스를 작성할 때 그 빈자리가 느껴질 것이며 반대로 하위 클래스를 작성할 때 굳이 쓰지 않는다면 `private` 멤버로 전환한다.

하위 클래스는 3개 정도 만들어보면 상위 클래스 검증이 가능하다.

항상 클래스 멤버 개방(public, protected)은 신중해야 하기 때문에 배포 전에 반드시 테스트하자.

## 3. 문서화

### Implementation Requirements

API 문서의 메서드 설명 끝에서 종종 **Implementation Requirements**로 되어있는 절이 있다.

이것은 메서드의 내부 동작 방식을 설명하는 것이다.

이는 `@implSpec` 태그를 붙여주면 자바독 도구가 자바8 이후부터 자동 생성해준다.

이 태그를 활성화하려면 아래 명령줄 매개변수를 지정해주면 된다.

```java
-tag "implSpec:a:Implementation Requirements:
```

## 4. 생성자는 재정의 가능 메서드 호출 금지

**상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행된다**

따라서 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.

이 때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않게 된다.

**private, final , static 메서드는 재정의가 불가능하다. 생성자에서 안심하고 호출 가능**

### Serializable 이나 Cloneable 을 상속용 클래스에서 구현할 때

`**clone`과 `readObject` 메서드도 생성자와 비슷한 효과를 내기 때문에 마찬가지로 재정의 가능 메서드를 호출하면 안된다.**

특히 `clone`은 메서드가 잘못되면 복제본뿐 아니라 원본 객체까지 피해를 줄 수 있기 때문에 주의해야 한다. 

**Serializable을 구현한 상속용 클래스가 `readResolve`나 `writeReplace` 메서드를 갖는다면 이 메서드를 `protected`로 선언해야 한다.** 

private로 선언할 시 하위클래스에서 무시된다.

## +상속용으로 구현하지 않은 클래스는 상속 금지

### 클래스를 `final`로 설정하기

### 생성자를 `private`이나 `package-private`로 설정한 뒤 `public` 정적 팩터리를 만들어주기
