# [아이템 26] 로(raw) 타입은 사용하지 말라

# 제네릭 타입

- 제네릭 클래스 혹은 제네릭 인터페이스
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이는 것
    
    ex_ List<String> 
    
- <> 안에 **매개변수화 타입** 선언
- 매개변수가 아닌 타입이 들어올 경우 컴파일러가 인지하고 컴파일에서 오류
- 타입 정보는 런타임시 소거됨

# 로(raw) 타입

제네릭 타입에서 매개변수를 전혀 사용하지 않을 때

ex_List<E> 

제네릭이 도래하기 전(Java5 이전) 코드와의 호환을 위한 수단,,

당연히 제네릭의 이점 하나도 못받고 인스턴스 타입 잘못 넣으면 컴파일되고 실행되어버림

**오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.**

런타임에 알아채면 이미 문제 겪는 코드와 원인 코드는 물리적으로 떨어져 있어 찾기 힘들어진다.

# 제네릭 매개변수로 Object는 가능

로타입: 제네릭 타입에서 컴파일이 완전히 관여하지 않겠다는 소리

Object 매개변수화한 제네릭: 모든 타입을 허용한다는 의사를 컴파일러에게 전달

### 제네릭 하위 타입 규칙

**모든 제네릭 타입은 로타입의 하위 타입이지만, 다른 제네릭 타입이 Object의 하위타입이 아님**

List<String>은 List를 매개변수로 받는 메서드의 매개변수로 호환 가능

List<String>은 List<Object>를 매개변수로 받는 메서드의 매개변수로 호환 불가능

→ 컴파일시 에러 발생 

## 비한정적 와일드카드 타입(unbounded wildcard type)

제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않은 경우 사용

**<?>** 

로타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.

반면 Collection<?>에는 null외에는 어떤 원소도 넣을 수 없다. → 컴파일에서 오류냄

# 예외사항

1. 클래스 리터럴에는 로 타입을 쓰기
    
    자바 명세 규칙이 그렇게 되어있다. List.class는 가능하지만 List<String>.class는 안된다
    
2. instanceof
    
    instanceof 연산자는 제네릭 타입에 적용 불가 (와일드카드 타입은 가능하지만 굳이,, 코드만 지저분해진다)
    

```java
if(o instanceof Set){
	Set<?> s = (Set<?>) o;
	...
}
```
